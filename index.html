<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>全部入りシューティング</title>
<style>
  body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
  canvas { background: #111; border: 1px solid #555; }
</style>
</head>
<body>
<canvas id="game" width="400" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let gameState = "title";

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup",   e => keys[e.key] = false);

let fireRate = 200;
let lastShot = 0;

// ★ パワーアップ（初期1WAY → 最大5WAY）
let shotLevel = 1;

let specialGauge = 0;
let specialReady = false;

const player = {
  x: canvas.width / 2,
  y: canvas.height - 40,
  w: 12,
  h: 12,
  speed: 4
};

const bullets = [];
const enemies = [];
const enemyBullets = [];
const items = [];
let boss = null;

let lastEnemyTime = 0;
let score = 0;
let gameOver = false;

// ★ ボス警告
let bossWarning = false;
let bossWarningTime = 0;

// ----------------------
// 自機ショット（可変WAY）
// ----------------------
function shoot() {
  const now = performance.now();
  if (now - lastShot < fireRate) return;
  lastShot = now;

  // shotLevel に応じて角度を生成
  const max = shotLevel;
  const spread = 0.4;
  const angles = [];

  if (max === 1) angles.push(0);
  else {
    for (let i = 0; i < max; i++) {
      const t = (i / (max - 1)) - 0.5;
      angles.push(t * spread);
    }
  }

  angles.forEach(a => {
    bullets.push({
      x: player.x,
      y: player.y - 15,
      w: 4,
      h: 10,
      vx: Math.sin(a) * 4,
      vy: -7
    });
  });
}

document.addEventListener("keydown", e => {
  if (gameState !== "playing") return;
  if (e.code === "Space") shoot();
  if (e.code === "KeyX" && specialReady) useSpecial();
});

// ----------------------
// スペシャル技
// ----------------------
function useSpecial() {
  specialReady = false;
  specialGauge = 0;

  enemies.length = 0;
  enemyBullets.length = 0;

  score += 50;
}

// ----------------------
// 敵生成（HP付き）
// ----------------------
function spawnEnemy(timestamp) {
  if (timestamp - lastEnemyTime > 1200) {
    const w = 30, h = 20;

    const r = Math.random();
    let type = "normal";
    let hp = 1;

    if (r < 0.15) { type = "homing"; hp = 2; }
    else if (r < 0.30) { type = "ram"; hp = 3; }
    else if (r < 0.40) { type = "split"; hp = 2; }

    enemies.push({
      x: Math.random() * (canvas.width - w) + w / 2,
      y: -20,
      w, h,
      speed: 1.5,
      type,
      hp,
      state: "aim",
      aimTime: timestamp,
      split: false,
      shootTime: 0
    });

    lastEnemyTime = timestamp;
  }
}

// ----------------------
// 誘導弾
// ----------------------
function enemyShoot(e, timestamp) {
  if (timestamp - e.shootTime > 2000) {
    enemyBullets.push({
      x: e.x,
      y: e.y,
      w: 6,
      h: 6,
      speed: 2,
      angle: Math.atan2(player.y - e.y, player.x - e.x),
      born: timestamp
    });
    e.shootTime = timestamp;
  }
}

function updateEnemyBullets(timestamp) {
  const turnRate = 0.03;

  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const b = enemyBullets[i];

    if (timestamp - b.born > 5000) {
      enemyBullets.splice(i, 1);
      continue;
    }

    const targetAngle = Math.atan2(player.y - b.y, player.x - b.x);
    let diff = targetAngle - b.angle;
    diff = Math.atan2(Math.sin(diff), Math.cos(diff));
    b.angle += diff * turnRate;

    b.x += Math.cos(b.angle) * b.speed;
    b.y += Math.sin(b.angle) * b.speed;

    if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
      enemyBullets.splice(i, 1);
    }
  }
}

// ----------------------
// 敵の更新
// ----------------------
function updateEnemies(timestamp) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];

    if (e.type === "normal") {
      e.y += e.speed;
    }

    if (e.type === "homing") {
      e.y += e.speed;
      enemyShoot(e, timestamp);
    }

    if (e.type === "ram") {
      if (e.state === "aim") {
        const angle = Math.atan2(player.y - e.y, player.x - e.x);
        e.vx = Math.cos(angle) * 3;
        e.vy = Math.sin(angle) * 3;
        if (timestamp - e.aimTime > 600) e.state = "dash";
      } else {
        e.x += e.vx;
        e.y += e.vy;
      }
    }

    if (e.type === "split" && !e.split && e.y > 200) {
      enemies.push({ x: e.x - 10, y: e.y, w: 20, h: 15, speed: 2, type: "normal", hp: 1 });
      enemies.push({ x: e.x + 10, y: e.y, w: 20, h: 15, speed: 2, type: "normal", hp: 1 });
      e.split = true;
    }

    if (e.y - e.h > canvas.height) enemies.splice(i, 1);
  }
}

// ----------------------
// ボス
// ----------------------
function spawnBoss() {
  boss = {
    x: canvas.width / 2,
    y: 100,
    w: 120,
    h: 60,
    hp: 80,
    shootTime: 0,
    baseX: canvas.width / 2,
    range: 60
  };
}

function bossShoot(timestamp) {
  if (timestamp - boss.shootTime > 1000) {
    const angles = [-0.3, 0, 0.3];
    angles.forEach(a => {
      enemyBullets.push({
        x: boss.x,
        y: boss.y,
        w: 8,
        h: 8,
        speed: 3,
        angle: a + Math.PI / 2,
        born: timestamp
      });
    });
    boss.shootTime = timestamp;
  }
}

function updateBoss(timestamp) {
  if (!boss) return;

  boss.x = boss.baseX + Math.sin(timestamp / 600) * boss.range;
  bossShoot(timestamp);

  for (let i = bullets.length - 1; i >= 0; i--) {
    if (isHit(bullets[i], boss)) {
      bullets.splice(i, 1);
      boss.hp--;
      if (boss.hp <= 0) {
        boss = null;
        score += 300;
      }
    }
  }
}

// ----------------------
// 当たり判定
// ----------------------
function isHit(a, b) {
  return (
    Math.abs(a.x - b.x) < (a.w + b.w) / 2 &&
    Math.abs(a.y - b.y) < (a.h + b.h) / 2
  );
}

// ----------------------
// 敵撃破 → アイテムドロップ
// ----------------------
function checkCollisions() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    for (let j = bullets.length - 1; j >= 0; j--) {
      if (isHit(enemies[i], bullets[j])) {
        bullets.splice(j, 1);
        enemies[i].hp--;

        if (enemies[i].hp <= 0) {
          // ★ アイテムドロップ（30%）
          if (Math.random() < 0.3) {
            items.push({
              x: enemies[i].x,
              y: enemies[i].y,
              w: 12,
              h: 12,
              vy: 2
            });
          }

          enemies.splice(i, 1);
          score += 10;

          specialGauge += 10;
          if (specialGauge >= 100) specialReady = true;
        }
        break;
      }
    }
  }
}

// ----------------------
// アイテム取得
// ----------------------
function updateItems() {
  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    it.y += it.vy;

    if (isHit(it, player)) {
      items.splice(i, 1);
      shotLevel = Math.min(5, shotLevel + 1);
      continue;
    }

    if (it.y > canvas.height + 20) items.splice(i, 1);
  }
}

// ----------------------
// 弾の更新
// ----------------------
function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;

    if (b.y < -20 || b.x < -20 || b.x > canvas.width + 20) {
      bullets.splice(i, 1);
    }
  }
}

// ----------------------
// 描画
// ----------------------
function drawPlayer() {
  ctx.fillStyle = "cyan";
  ctx.beginPath();
  ctx.moveTo(player.x, player.y - player.h / 2);
  ctx.lineTo(player.x - player.w / 2, player.y + player.h / 2);
  ctx.lineTo(player.x + player.w / 2, player.y + player.h / 2);
  ctx.closePath();
  ctx.fill();
}

function drawBullets() {
  ctx.fillStyle = "yellow";
  bullets.forEach(b => {
    ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2, b.w, b.h);
  });
}

function drawEnemies() {
  enemies.forEach(e => {
    if (e.type === "normal") ctx.fillStyle = "red";
    if (e.type === "homing") ctx.fillStyle = "lime";
    if (e.type === "ram")    ctx.fillStyle = "orange";
    if (e.type === "split")  ctx.fillStyle = "pink";

    ctx.beginPath();
    ctx.moveTo(e.x, e.y - e.h / 2);
    ctx.lineTo(e.x - e.w / 2, e.y + e.h / 2);
    ctx.lineTo(e.x + e.w / 2, e.y + e.h / 2);
    ctx.closePath();
    ctx.fill();
  });
}

function drawEnemyBullets() {
  ctx.fillStyle = "orange";
  enemyBullets.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.w / 2, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawItems() {
  ctx.fillStyle = "cyan";
  items.forEach(it => {
    ctx.beginPath();
    ctx.arc(it.x, it.y, it.w / 2, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawBoss() {
  if (!boss) return;
  ctx.fillStyle = "purple";
  ctx.beginPath();
  ctx.moveTo(boss.x, boss.y - boss.h / 2);
  ctx.lineTo(boss.x - boss.w / 2, boss.y + boss.h / 2);
  ctx.lineTo(boss.x + boss.w / 2, boss.y + boss.h / 2);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "white";
  ctx.fillText("BOSS HP: " + boss.hp, boss.x - 40, boss.y - boss.h / 2 - 10);
}

// ----------------------
// UI（SPゲージ）
// ----------------------
function drawUI() {
  ctx.fillStyle = "white";
  ctx.font = "16px sans-serif";
  ctx.fillText("SCORE: " + score, 10, 20);

  // SPゲージバー
  ctx.fillStyle = "#444";
  ctx.fillRect(10, 40, 100, 12);

  ctx.fillStyle = specialReady ? "cyan" : "yellow";
  ctx.fillRect(10, 40, Math.min(specialGauge, 100), 12);

  ctx.strokeStyle = "white";
  ctx.strokeRect(10, 40, 100, 12);

  if (specialReady) {
    ctx.fillStyle = "white";
    ctx.fillText("Xでスペシャル！", 120, 50);
  }

  ctx.fillStyle = "white";
  ctx.fillText("SHOT: " + shotLevel + "WAY", 10, 70);
}

// ----------------------
// ボス警告
// ----------------------
function drawBossWarning() {
  ctx.fillStyle = "red";
  ctx.font = "40px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("⚠ WARNING ⚠", canvas.width / 2, canvas.height / 2);

  ctx.font = "20px sans-serif";
  ctx.fillText("Boss Approaching...", canvas.width / 2, canvas.height / 2 + 40);

  ctx.textAlign = "start";
}

// ----------------------
// タイトル
// ----------------------
function drawTitle() {
  ctx.fillStyle = "white";
  ctx.font = "32px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("SHOOTING GAME", canvas.width / 2, 250);

  ctx.font = "20px sans-serif";
  ctx.fillText("Press ENTER to Start", canvas.width / 2, 320);
  ctx.textAlign = "start";
}

// ----------------------
// ゲームオーバー
// ----------------------
function drawGameOver() {
  ctx.fillStyle = "white";
  ctx.font = "32px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("GAME OVER", canvas.width / 2, 250);

  ctx.font = "20px sans-serif";
  ctx.fillText("Press ENTER to Restart", canvas.width / 2, 320);
  ctx.textAlign = "start";
}

document.addEventListener("keydown", e => {
  if (e.code === "Enter") {
    if (gameState === "title" || gameState === "gameover") {
      startGame();
    }
  }
});

// ----------------------
// ゲーム開始
// ----------------------
function startGame() {
  gameState = "playing";
  score = 0;
  specialGauge = 0;
  specialReady = false;
  enemies.length = 0;
  enemyBullets.length = 0;
  bullets.length = 0;
  items.length = 0;
  boss = null;
  gameOver = false;
  bossWarning = false;
  shotLevel = 1;
  player.x = canvas.width / 2;
}

// ----------------------
// メインループ
// ----------------------
function loop(timestamp) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === "title") {
    drawTitle();
    requestAnimationFrame(loop);
    return;
  }

  if (gameState === "gameover") {
    drawGameOver();
    requestAnimationFrame(loop);
    return;
  }

  if (!gameOver) {
    spawnEnemy(timestamp);
    updateEnemies(timestamp);
    updateEnemyBullets(timestamp);
    updateBullets();
    updateItems();
    checkCollisions();
    checkEnemyBulletHit();

    // ★ ボス警告 → ボス出現
    if (!boss && !bossWarning && score >= 100) {
      bossWarning = true;
      bossWarningTime = timestamp;
    }

    if (bossWarning && timestamp - bossWarningTime > 2000) {
      spawnBoss();
      bossWarning = false;
    }

    updateBoss(timestamp);

    if (keys["ArrowLeft"])  player.x -= player.speed;
    if (keys["ArrowRight"]) player.x += player.speed;
    player.x = Math.max(player.w, Math.min(canvas.width - player.w, player.x));
  } else {
    gameState = "gameover";
  }

  drawPlayer();
  drawBullets();
  drawEnemies();
  drawEnemyBullets();
  drawItems();
  drawBoss();
  drawUI();

  if (bossWarning) drawBossWarning();

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
